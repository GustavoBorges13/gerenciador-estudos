# Nome do nosso workflow de automação
name: Build Application

# Gatilho: Este workflow irá rodar toda vez que uma nova "Release" for publicada no GitHub.
on:
  release:
    types: [published]

jobs:
  build:
    # Nome do nosso job de build
    name: Build on ${{ matrix.os }}

    # Estratégia de Matriz: Rodar este job em paralelo nos 3 sistemas operacionais
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    # Define qual máquina virtual será usada para cada job da matriz
    runs-on: ${{ matrix.os }}

    steps:
      # Passo 1: Baixar o código do seu repositório para a máquina virtual
      - name: Checkout repository
        uses: actions/checkout@v4

      # Passo 2: Configurar o ambiente Python na máquina virtual
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11' # Usar uma versão estável do Python

      # Passo 3: Instalar as dependências do projeto e a ferramenta de build (PyInstaller)
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e . # Instala seu projeto e suas dependências (PySide6, PyMuPDF)
          pip install pyinstaller # Instala a ferramenta de empacotamento

      # Passo 4: Instalar ferramentas adicionais APENAS para o build do Linux (AppImage)
      - name: Install Linux AppImage tools
        if: runner.os == 'Linux'
        run: |
          wget -c "https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage"
          wget -c "https://github.com/linuxdeploy/linuxdeploy-plugin-qt/releases/download/continuous/linuxdeploy-plugin-qt-x86_64.AppImage"
          chmod +x linuxdeploy-x86_64.AppImage
          chmod +x linuxdeploy-plugin-qt-x86_64.AppImage
          
      # Passo 5: Rodar o PyInstaller para criar o executável
      - name: Run PyInstaller
        run: |
          pyinstaller src/gerenciador_estudos/__main__.py \
            --name "GerenciadorDeEstudos" \
            --onefile \
            --windowed \
            --icon "src/gerenciador_estudos/assets/icone.ico"

      # Passo 6: Criar o AppImage APENAS para o build do Linux
      - name: Create AppImage
        if: runner.os == 'Linux'
        run: |
          export QT_QPA_PLATFORMTHEME=qt6ct # Ajuda o plugin a encontrar o tema correto
          ./linuxdeploy-x86_64.AppImage --appdir dist/GerenciadorDeEstudos \
            --plugin qt \
            --output appimage
      
      # Passo 7: Preparar os artefatos para upload (renomear e zipar o .app do macOS)
      - name: Prepare artifacts for upload
        shell: bash
        run: |
          # Define o nome base do artefato usando o nome do repositório
          ARTIFACT_NAME=${{ github.event.repository.name }}
          # Pega o nome da tag da release (ex: v1.0.0)
          TAG_NAME=${{ github.ref_name }}

          # Renomeia os artefatos para incluir o SO e a versão
          if [ "$RUNNER_OS" == "Windows" ]; then
            mv dist/GerenciadorDeEstudos.exe dist/${ARTIFACT_NAME}-${TAG_NAME}-windows.exe
            echo "ASSET_PATH=dist/${ARTIFACT_NAME}-${TAG_NAME}-windows.exe" >> $GITHUB_ENV
          elif [ "$RUNNER_OS" == "macOS" ]; then
            # O .app é um diretório, então precisamos zipá-lo
            zip -r dist/${ARTIFACT_NAME}-${TAG_NAME}-macos.zip dist/GerenciadorDeEstudos.app
            echo "ASSET_PATH=dist/${ARTIFACT_NAME}-${TAG_NAME}-macos.zip" >> $GITHUB_ENV
          elif [ "$RUNNER_OS" == "Linux" ]; then
            # O AppImage já tem um nome longo, vamos padronizá-lo
            mv GerenciadorDeEstudos*.AppImage dist/${ARTIFACT_NAME}-${TAG_NAME}-linux.AppImage
            echo "ASSET_PATH=dist/${ARTIFACT_NAME}-${TAG_NAME}-linux.AppImage" >> $GITHUB_ENV
          fi
          
      # Passo 8: Fazer o upload do artefato final para a Release do GitHub
      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        with:
          # O token é necessário para dar permissão para a Action fazer o upload
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # URL para onde o upload será feito (pega da release que acionou o workflow)
          upload_url: ${{ github.event.release.upload_url }}
          # Caminho do arquivo que será enviado
          asset_path: ${{ env.ASSET_PATH }}
          # Nome que o arquivo terá na página da Release
          asset_name: ${{ env.ASSET_PATH }}
          # Tipo do conteúdo
          asset_content_type: application/octet-stream```

---

### Passo 2: Como Usar este Workflow

1.  **Commit e Push:** Adicione a pasta `.github` com o arquivo `build.yml` ao seu repositório e faça o push para o GitHub.
    ```bash
    git add .github/
    git commit -m "feat: Add GitHub Actions workflow for automated builds"
    git push
    ```

2.  **Crie uma Nova Release no GitHub:**
    A automação agora está pronta, esperando pelo gatilho. Para acioná-la:
    *   Vá para a página principal do seu repositório no GitHub.
    *   Clique em **"Releases"** na barra lateral direita.
    *   Clique em **"Draft a new release"**.
    *   Clique em **"Choose a tag"**, digite um novo número de versão (ex: `v1.0.0`) e clique em **"Create new tag"**.
    *   Dê um título para a sua release (ex: "Versão 1.0.0 - Lançamento Inicial").
    *   Escreva uma breve descrição das novidades.
    *   Clique em **"Publish release"**.

3.  **A Mágica Acontece:**
    *   Assim que você publicar a release, vá para a aba **"Actions"** no seu repositório.
    *   Você verá seu workflow "Build Application" rodando. Se clicar nele, verá os três jobs (Windows, macOS, Linux) executando em paralelo.
    *   Aguarde alguns minutos. Quando todos os jobs terminarem com sucesso (ficarem verdes), volte para a página da sua release.
    *   Os três arquivos (`.exe`, `.zip`, `.AppImage`) estarão anexados na seção **"Assets"**, prontos para serem baixados!

### Notas Importantes

*   **Ícone do macOS:** O PyInstaller no macOS prefere um ícone no formato `.icns`. Você pode converter seu `.ico` para `.icns` usando uma ferramenta online e adicioná-lo à pasta `assets`. Depois, você pode adicionar uma lógica `if` no passo do PyInstaller para usar o ícone correto em cada SO.
*   **Primeira Execução:** A primeira vez que o workflow rodar pode demorar um pouco mais, pois o GitHub Actions precisa baixar e armazenar em cache algumas dependências.
*   **Code Signing:** Para uma distribuição ainda mais profissional, especialmente no Windows e macOS, o próximo passo seria "assinar" seus executáveis com um certificado de desenvolvedor. Isso é um processo mais complexo, mas evita que os usuários vejam avisos de segurança ao rodar seu programa.

Parabéns! Com este workflow, você alcançou um nível de automação e profissionalismo que a grande maioria dos projetos nunca atinge.
