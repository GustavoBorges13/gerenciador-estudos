# Nome do nosso workflow de automação
name: Build Application

# Gatilhos:
on:
  # 1. Aciona quando uma nova "Release" for publicada (para seus lançamentos oficiais)
  release:
    types: [published]
  
  # 2. Permite acionar manualmente a qualquer momento (para testes)
  workflow_dispatch: {}

jobs:
  build:
    # Nome do nosso job de build
    name: Build on ${{ matrix.os }}

    # Estratégia de Matriz: Rodar este job em paralelo nos 3 sistemas operacionais
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]

    # Define qual máquina virtual será usada para cada job da matriz
    runs-on: ${{ matrix.os }}

    steps:
      # Passo 1: Baixar o código do seu repositório para a máquina virtual
      - name: Checkout repository
        uses: actions/checkout@v4

      # Passo 2: Configurar o ambiente Python na máquina virtual
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11' # Usar uma versão estável do Python

      # Passo 3: Instalar as dependências do projeto e a ferramenta de build (PyInstaller)
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -e . # Instala seu projeto e suas dependências (PySide6, PyMuPDF)
          pip install pyinstaller # Instala a ferramenta de empacotamento

      # Passo 4: Instalar ferramentas adicionais APENAS para o build do Linux (AppImage)
      - name: Install Linux AppImage tools
        if: runner.os == 'Linux'
        run: |
          wget -c "https://github.com/linuxdeploy/linuxdeploy/releases/download/continuous/linuxdeploy-x86_64.AppImage"
          wget -c "https://github.com/linuxdeploy/linuxdeploy-plugin-qt/releases/download/continuous/linuxdeploy-plugin-qt-x86_64.AppImage"
          chmod +x linuxdeploy-x86_64.AppImage
          chmod +x linuxdeploy-plugin-qt-x86_64.AppImage
          
      # Passo 5: Rodar o PyInstaller para criar o executável
      - name: Run PyInstaller
        shell: bash # Usar bash em todos os SOs para consistência
        run: |
          # Define o ícone a ser usado com base no sistema operacional
          if [ "$RUNNER_OS" == "macOS" ]; then
            ICON_PATH="src/gerenciador_estudos/assets/icone.icns"
          else
            ICON_PATH="src/gerenciador_estudos/assets/icone.ico"
          fi
          
          # Roda o PyInstaller com --onedir (mais robusto) e o ícone correto
          pyinstaller src/gerenciador_estudos/__main__.py \
            --name "GerenciadorDeEstudos" \
            --noconfirm \
            --onedir \
            --windowed \
            --icon "$ICON_PATH" \
            --add-data "src/assets:assets"

      # Passo 6: Criar o AppImage APENAS para o build do Linux
      - name: Create AppImage
        if: runner.os == 'Linux'
        run: |
          # No modo --onedir, o AppDir é o próprio diretório de saída do PyInstaller
          ./linuxdeploy-x86_64.AppImage --appdir dist/GerenciadorDeEstudos \
            --plugin qt \
            --output appimage
      
      # Passo 7: Preparar os artefatos para upload (AGORA LIDANDO COM DIRETÓRIOS)
      - name: Prepare artifacts for upload
        shell: bash
        run: |
          ARTIFACT_NAME=${{ github.event.repository.name }}
          TAG_NAME=${{ github.ref_name }}

          # Como estamos usando --onedir, precisamos zipar o resultado em todos os SOs
          if [ "$RUNNER_OS" == "Windows" ]; then
            # O .exe estará dentro da pasta dist/GerenciadorDeEstudos
            7z a -tzip "dist/${ARTIFACT_NAME}-${TAG_NAME}-windows.zip" ./dist/GerenciadorDeEstudos/
            echo "ASSET_PATH=dist/${ARTIFACT_NAME}-${TAG_NAME}-windows.zip" >> $GITHUB_ENV
          elif [ "$RUNNER_OS" == "macOS" ]; then
            # O .app é a própria pasta
            7z a -tzip "dist/${ARTIFACT_NAME}-${TAG_NAME}-macos.zip" ./dist/GerenciadorDeEstudos.app/
            echo "ASSET_PATH=dist/${ARTIFACT_NAME}-${TAG_NAME}-macos.zip" >> $GITHUB_ENV
          elif [ "$RUNNER_OS" == "Linux" ]; then
            mv GerenciadorDeEstudos*.AppImage dist/${ARTIFACT_NAME}-${TAG_NAME}-linux.AppImage
            echo "ASSET_PATH=dist/${ARTIFACT_NAME}-${TAG_NAME}-linux.AppImage" >> $GITHUB_ENV
          fi
          
      # Passo 8: Fazer o upload do artefato final para a Release do GitHub
      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        with:
          # O token é necessário para dar permissão para a Action fazer o upload
          github_token: ${{ secrets.GITHUB_TOKEN }}
          # URL para onde o upload será feito (pega da release que acionou o workflow)
          upload_url: ${{ github.event.release.upload_url }}
          # Caminho do arquivo que será enviado
          asset_path: ${{ env.ASSET_PATH }}
          # Nome que o arquivo terá na página da Release
          asset_name: ${{ env.ASSET_PATH }}
          # Tipo do conteúdo
          asset_content_type: application/octet-stream
